package config

import (
	"os"
	"path/filepath"
	"strings"

	"github.com/TouchBistro/goutils/file"
	"github.com/cszatma/dot/util"
	"github.com/pkg/errors"
	"gopkg.in/yaml.v2"
)

var (
	config   DotConfig
	lockfile Lockfile
)

type Dotfile struct {
	Src  string `yaml:"src"`
	Dest string `yaml:"dest"`
	OS   string `yaml:"os"`
}

type DotConfig struct {
	Dotfiles map[string]Dotfile `yaml:"dotfiles"`
}

type Lockfile struct {
	DotfilesDir string `yaml:"dotfilesDir"`
	IsSetup     bool   `yaml:"setup"`
}

func Config() *DotConfig {
	return &config
}

func loadDotConfig() error {
	configPath := filepath.Join(lockfile.DotfilesDir, "dot.yml")
	if !file.FileOrDirExists(configPath) {
		return errors.Errorf("No such file %s", configPath)
	}

	cf, err := os.Open(configPath)
	if err != nil {
		return errors.Wrapf(err, "Failed to open config file at path %s", configPath)
	}
	defer cf.Close()

	dec := yaml.NewDecoder(cf)
	err = dec.Decode(&config)
	if err != nil {
		return errors.Wrap(err, "Failed to decode config file")
	}

	for name, dotfile := range config.Dotfiles {
		// Remove dotfiles that are not for the current os
		if dotfile.OS != "*" {
			osList := strings.Split(dotfile.OS, ",")
			currentOS := util.CurrentOS()
			isValidOS := false

			for _, os := range osList {
				if os == currentOS {
					isValidOS = true
					break
				}
			}

			if !isValidOS {
				delete(config.Dotfiles, name)
			}
		}

		// Make src paths absolute
		if !filepath.IsAbs(dotfile.Src) {
			dotfile.Src = filepath.Join(lockfile.DotfilesDir, dotfile.Src)
		}

		// Expand tilde in dest paths
		if strings.HasPrefix(dotfile.Dest, "~") {
			base := strings.TrimPrefix(dotfile.Dest, "~")
			dotfile.Dest = filepath.Join(os.Getenv("HOME"), base)
		}

		config.Dotfiles[name] = dotfile
	}

	return nil
}

func Init() error {
	lockfilePath := filepath.Join(os.Getenv("HOME"), ".dot.lock")
	if !file.FileOrDirExists(lockfilePath) {
		lockfile = Lockfile{}
	} else {
		lf, err := os.Open(lockfilePath)
		if err != nil {
			return errors.Wrapf(err, "Failed to open lockfile at path %s", lockfilePath)
		}
		defer lf.Close()

		dec := yaml.NewDecoder(lf)
		err = dec.Decode(&lockfile)
		if err != nil {
			return errors.Wrap(err, "Failed to decode lockfile")
		}
	}

	if !lockfile.IsSetup {
		return nil
	}

	err := loadDotConfig()
	return errors.Wrap(err, "Failed to load dot config file")
}

func SaveLockfile() error {
	lockfilePath := filepath.Join(os.Getenv("HOME"), ".dot.lock")
	lf, err := os.Create(lockfilePath)
	if err != nil {
		return errors.Wrapf(err, "Failed to create lockfile at %s", lockfilePath)
	}
	defer lf.Close()

	// Add header comment
	_, err = lf.WriteString("# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n\n")
	if err != nil {
		return errors.Wrap(err, "Failed to add header comment to lockfile")
	}

	enc := yaml.NewEncoder(lf)
	err = enc.Encode(&lockfile)
	return errors.Wrapf(err, "Failed to write lockfile to %s", lockfilePath)
}

func IsSetup() bool {
	return lockfile.IsSetup
}

func Setup(dotfilesDir string) error {
	lockfile.DotfilesDir = dotfilesDir
	lockfile.IsSetup = true

	err := loadDotConfig()
	if err != nil {
		return errors.Wrap(err, "Failed to load dot config file")
	}

	err = SaveLockfile()
	return errors.Wrap(err, "Failed to save lockfile")
}

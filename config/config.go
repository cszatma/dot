package config

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"

	"github.com/TouchBistro/goutils/file"
	"github.com/cszatma/dot/util"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	"gopkg.in/yaml.v2"
)

const (
	lockfileName = ".dot.lock"
)

var (
	config   DotConfig
	lockfile Lockfile
)

type DotfileConfig struct {
	Src  string `yaml:"src"`
	Dest string `yaml:"dest"`
	OS   string `yaml:"os"`
}

type DotConfig struct {
	Dotfiles map[string]DotfileConfig `yaml:"dotfiles"`
}

type DotfileInfo struct {
	SrcHash  string `yaml:"srcHash"`
	DestHash string `yaml:"destHash"`
}

type Lockfile struct {
	DotfilesDir string                 `yaml:"dotfilesDir"`
	IsSetup     bool                   `yaml:"setup"`
	Dotfiles    map[string]DotfileInfo `yaml:"dotfiles"`
}

func Config() *DotConfig {
	return &config
}

func loadDotConfig() error {
	configPath := filepath.Join(lockfile.DotfilesDir, "dot.yml")
	if !file.FileOrDirExists(configPath) {
		return errors.Errorf("No such file %s", configPath)
	}

	cf, err := os.Open(configPath)
	if err != nil {
		return errors.Wrapf(err, "Failed to open config file at path %s", configPath)
	}
	defer cf.Close()

	dec := yaml.NewDecoder(cf)
	err = dec.Decode(&config)
	if err != nil {
		return errors.Wrap(err, "Failed to decode config file")
	}

	parsedDotfiles := make(map[string]DotfileConfig)
	for name, dotfile := range config.Dotfiles {
		// Remove dotfiles that are not for the current os
		if dotfile.OS != "*" {
			osList := strings.Split(dotfile.OS, ",")
			currentOS := util.CurrentOS()
			isValidOS := false

			for _, os := range osList {
				if os == currentOS {
					isValidOS = true
					break
				}
			}

			if !isValidOS {
				continue
			}
		}

		// Make src paths absolute
		if !filepath.IsAbs(dotfile.Src) {
			dotfile.Src = filepath.Join(lockfile.DotfilesDir, dotfile.Src)
		}

		// Expand tilde in dest paths
		if strings.HasPrefix(dotfile.Dest, "~") {
			base := strings.TrimPrefix(dotfile.Dest, "~")
			dotfile.Dest = filepath.Join(os.Getenv("HOME"), base)
		}

		parsedDotfiles[name] = dotfile
	}

	config.Dotfiles = parsedDotfiles
	return nil
}

func Init() error {
	lockfilePath := filepath.Join(os.Getenv("HOME"), lockfileName)
	if !file.FileOrDirExists(lockfilePath) {
		lockfile = Lockfile{}
		return nil
	}

	lf, err := os.Open(lockfilePath)
	if err != nil {
		return errors.Wrapf(err, "Failed to open lockfile at path %s", lockfilePath)
	}
	defer lf.Close()

	dec := yaml.NewDecoder(lf)
	err = dec.Decode(&lockfile)
	if err != nil {
		return errors.Wrap(err, "Failed to decode lockfile")
	}

	if !lockfile.IsSetup {
		return nil
	}

	err = loadDotConfig()
	return errors.Wrap(err, "Failed to load dot config file")
}

func SaveLockfile() error {
	lockfilePath := filepath.Join(os.Getenv("HOME"), lockfileName)
	lf, err := os.Create(lockfilePath)
	if err != nil {
		return errors.Wrapf(err, "Failed to create lockfile at %s", lockfilePath)
	}
	defer lf.Close()

	// Add header comment
	_, err = lf.WriteString("# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n\n")
	if err != nil {
		return errors.Wrap(err, "Failed to add header comment to lockfile")
	}

	enc := yaml.NewEncoder(lf)
	err = enc.Encode(&lockfile)
	return errors.Wrapf(err, "Failed to write lockfile to %s", lockfilePath)
}

func IsSetup() bool {
	return lockfile.IsSetup
}

func Setup(dotfilesDir string) error {
	lockfile.DotfilesDir = dotfilesDir
	lockfile.IsSetup = true

	err := loadDotConfig()
	if err != nil {
		return errors.Wrap(err, "Failed to load dot config file")
	}

	// Get hashes for src and dest
	// This will be used to determine if the dotfiles are out of date
	log.Debugln("Saving hashes of dotfiles")
	lockfile.Dotfiles = make(map[string]DotfileInfo)
	for name, dotfile := range config.Dotfiles {
		log.Debugf("Saving hashes of %s\n", name)
		srcHash, err := util.FileChecksum(dotfile.Src)
		if err != nil {
			return errors.Wrapf(err, "failed to get checksum of %s", dotfile.Src)
		}

		destHash := make([]byte, 0)
		if file.FileOrDirExists(dotfile.Dest) {
			destHash, err = util.FileChecksum(dotfile.Dest)
			if err != nil {
				return errors.Wrapf(err, "failed to get checksum of %s", dotfile.Dest)
			}
		}

		lockfile.Dotfiles[name] = DotfileInfo{
			SrcHash:  string(srcHash),
			DestHash: string(destHash),
		}
	}
	log.Debugln("Finished saving hashes")

	// Create backups of dotfiles
	// This way we still have the original since dot will be messing with them
	log.Debugln("Creating backups of dotfiles")
	for name, dotfile := range config.Dotfiles {
		// Dotfile doesn't exist, nothing to backup
		if !file.FileOrDirExists(dotfile.Dest) {
			continue
		}

		log.Debugf("Creating backup of %s\n", name)

		backupPath := dotfile.Dest + ".bak"
		err = file.CopyFile(dotfile.Dest, backupPath)
		if err != nil {
			return errors.Wrapf(err, "Failed to create backup of %s at %s", name, backupPath)
		}
	}
	log.Debugln("Finished creating backups")

	err = SaveLockfile()
	return errors.Wrap(err, "Failed to save lockfile")
}

func Apply(dotfileNames []string, force bool) error {
	// Make sure it is safe to apply updates
	// If there are any dotfiles whose hash is not equal to the hash
	// in the lockfile then it has been manually modified
	log.Debugln("Checking if dotfiles have been modified")
	for _, name := range dotfileNames {
		dotfile := config.Dotfiles[name]
		dotfileInfo := lockfile.Dotfiles[name]

		destHash := make([]byte, 0)
		if file.FileOrDirExists(dotfile.Dest) {
			var err error
			destHash, err = util.FileChecksum(dotfile.Dest)
			if err != nil {
				return errors.Wrapf(err, "failed to get checksum of %s", dotfile.Dest)
			}
		}

		if !bytes.Equal(destHash, []byte(dotfileInfo.DestHash)) {
			if !force {
				return errors.Errorf("%s was manually modified", dotfile.Dest)
			}

			log.Debugf("dotfile %s was modified but force mode is enabled, updating...\n", name)
			dotfileInfo.DestHash = string(destHash)
			lockfile.Dotfiles[name] = dotfileInfo
		}
	}

	// Update src hashes if they are out of date
	log.Debugln("Checking if dotfile source hashes are out of date")
	for _, name := range dotfileNames {
		dotfile := config.Dotfiles[name]
		dotfileInfo := lockfile.Dotfiles[name]

		srcHash, err := util.FileChecksum(dotfile.Src)
		if err != nil {
			return errors.Wrapf(err, "failed to get checksum of %s", dotfile.Src)
		}

		if !bytes.Equal(srcHash, []byte(dotfileInfo.SrcHash)) {
			log.Debugf("Source hash of %s out of date, updating...\n", name)
			dotfileInfo.SrcHash = string(srcHash)
			lockfile.Dotfiles[name] = dotfileInfo
		}
	}

	// If the src and dest hashes are the same there is nothing to apply
	log.Debugln("Checking if dotfiles are outdated")
	outdatedNames := make([]string, 0, len(dotfileNames))
	for _, name := range dotfileNames {
		dotfileInfo := lockfile.Dotfiles[name]
		if bytes.Equal([]byte(dotfileInfo.SrcHash), []byte(dotfileInfo.DestHash)) {
			log.Infof("%s is up to date with source, skipping", name)
		}

		outdatedNames = append(outdatedNames, name)
	}

	// Apply src to dest
	// TODO would be nice if this behaved like an automic transaction
	// i.e. if one failed any successful ones would be rolled back
	// and the user could retry rather than leaving in a partially successful state
	// for now the user will just need to manually retry the ones that failed though
	for _, name := range outdatedNames {
		dotfile := config.Dotfiles[name]
		err := file.CopyFile(dotfile.Src, dotfile.Dest)
		if err != nil {
			return errors.Wrapf(err, "failed to apply changes to %s", name)
		}

		// Update dest hash since dest was updated
		dotfileInfo := lockfile.Dotfiles[name]
		dotfileInfo.DestHash = dotfileInfo.SrcHash
		lockfile.Dotfiles[name] = dotfileInfo
		log.Infof("Applied changes to dotfile %s", name)
	}

	log.Debugln("Finished applying changes to dotfiles")

	err := SaveLockfile()
	return errors.Wrap(err, "Failed to save lockfile")
}
